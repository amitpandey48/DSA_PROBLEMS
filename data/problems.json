[
  {
    "id": 1,
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "category": "array",
    "difficulty": "Easy",
    "constraints": [
      "2 ≤ nums.length ≤ 10⁴",
      "-10⁹ ≤ nums[i] ≤ 10⁹",
      "-10⁹ ≤ target ≤ 10⁹",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      }
    ],
    "tags": ["hash-table", "array"]
  },
  {
    "id": 2,
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "category": "linkedlist",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the list is the range [0, 5000]",
      "-5000 ≤ Node.val ≤ 5000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The linked list is reversed."
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": "The linked list with two nodes is reversed."
      }
    ],
    "tags": ["linked-list", "recursion"]
  },
  {
    "id": 3,
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.",
    "category": "stack",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ s.length ≤ 10⁴",
      "s consists of parentheses only '()[]{}'."
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "The string contains valid parentheses."
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "All brackets are properly matched."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "The brackets are not properly matched."
      }
    ],
    "tags": ["stack", "string"]
  },
  {
    "id": 4,
    "title": "Implement Queue using Stacks",
    "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).",
    "category": "queue",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ x ≤ 9",
      "At most 100 calls will be made to push, pop, peek, and empty",
      "All the calls to pop and peek are valid"
    ],
    "examples": [
      {
        "input": "[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
        "output": "[null, null, null, 1, 1, false]",
        "explanation": "MyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false"
      }
    ],
    "tags": ["stack", "design", "queue"]
  },
  {
    "id": 5,
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 ≤ Node.val ≤ 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "Inorder traversal visits left subtree, root, then right subtree."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree returns empty array."
      }
    ],
    "tags": ["stack", "tree", "depth-first-search"]
  },
  {
    "id": 6,
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
    "category": "graph",
    "difficulty": "Medium",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 ≤ m, n ≤ 300",
      "grid[i][j] is '0' or '1'"
    ],
    "examples": [
      {
        "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
        "output": "1",
        "explanation": "There is one island formed by connected 1's."
      }
    ],
    "tags": ["depth-first-search", "breadth-first-search", "union-find"]
  },
  {
    "id": 7,
    "title": "Contains Duplicate",
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "category": "hashing",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ nums.length ≤ 10⁵",
      "-10⁹ ≤ nums[i] ≤ 10⁹"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true",
        "explanation": "The value 1 appears twice in the array."
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false",
        "explanation": "All elements are distinct."
      }
    ],
    "tags": ["array", "hash-table", "sorting"]
  },
  {
    "id": 8,
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "category": "array",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ nums.length ≤ 10⁵",
      "-10⁴ ≤ nums[i] ≤ 10⁴"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "[4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "Single element array returns that element."
      }
    ],
    "tags": ["array", "divide-and-conquer", "dynamic-programming"]
  },
  {
    "id": 9,
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.",
    "category": "linkedlist",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 ≤ Node.val ≤ 100",
      "Both list1 and list2 are sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "The merged list is sorted."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty."
      }
    ],
    "tags": ["linked-list", "recursion"]
  },
  {
    "id": 10,
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with the specified methods.",
    "category": "stack",
    "difficulty": "Medium",
    "constraints": [
      "-2³¹ ≤ val ≤ 2³¹ - 1",
      "Methods pop, top and getMin operations will always be called on non-empty stacks",
      "At most 3 * 10⁴ calls will be made to push, pop, top, and getMin"
    ],
    "examples": [
      {
        "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]",
        "output": "[null,null,null,null,-3,null,0,-2]",
        "explanation": "MinStack operations maintain minimum efficiently."
      }
    ],
    "tags": ["stack", "design"]
  },
  {
    "id": 11,
    "title": "Binary Tree Level Order Traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "category": "tree",
    "difficulty": "Medium",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000]",
      "-1000 ≤ Node.val ≤ 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "Level by level traversal of the tree."
      }
    ],
    "tags": ["tree", "breadth-first-search"]
  },
  {
    "id": 12,
    "title": "Course Schedule",
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
    "category": "graph",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ numCourses ≤ 2000",
      "0 ≤ prerequisites.length ≤ 5000",
      "prerequisites[i].length == 2",
      "0 ≤ ai, bi < numCourses",
      "All the pairs prerequisites[i] are unique"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "There are cycles in the prerequisites, making it impossible to finish all courses."
      }
    ],
    "tags": ["depth-first-search", "breadth-first-search", "graph", "topological-sort"]
  },
  {
    "id": 13,
    "title": "Group Anagrams",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "category": "hashing",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ strs.length ≤ 10⁴",
      "0 ≤ strs[i].length ≤ 100",
      "strs[i] consists of lowercase English letters"
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "Anagrams are grouped together."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Empty string forms its own group."
      }
    ],
    "tags": ["array", "hash-table", "string", "sorting"]
  },
  {
    "id": 14,
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "category": "array",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ prices.length ≤ 10⁵",
      "0 ≤ prices[i] ≤ 10⁴"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transaction is done, i.e. max profit = 0."
      }
    ],
    "tags": ["array", "dynamic-programming"]
  },
  {
    "id": 15,
    "title": "Linked List Cycle",
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.",
    "category": "linkedlist",
    "difficulty": "Easy",
    "constraints": [
      "The number of the nodes in the list is in the range [0, 10⁴]",
      "-10⁵ ≤ Node.val ≤ 10⁵",
      "pos is -1 or a valid index in the linked-list"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "tags": ["hash-table", "linked-list", "two-pointers"]
  }
]
